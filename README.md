### Описание программы

Данная программа реализует алгоритм Хаффмана для сжатия и распаковки текстовых файлов. Она позволяет пользователю выбрать режим работы: **кодирование текста** или **декодирование текста**, сохранить результаты в файлы, а также использовать закодированные данные и дерево Хаффмана для восстановления исходного текста.

---

### Использование программы

#### Режимы работы
1. **Кодирование текста:**
   - Программа считывает текст из файла, генерирует коды Хаффмана для символов, кодирует текст и сохраняет:
     - Закодированные данные в текстовый файл.
     - Дерево Хаффмана в текстовый файл (формат: `символ:код`).

2. **Декодирование текста:**
   - Программа считывает закодированный текст и дерево Хаффмана из файлов, восстанавливает исходный текст и сохраняет его в файл.

---

### Примеры запуска

#### Кодирование текста:
1. Запустите программу.
2. Выберите режим работы, введя `1`.
3. Укажите:
   - Имя файла с текстом для кодирования, например: `input.txt`.
   - Имя файла для сохранения закодированных данных, например: `encoded.txt`.
   - Имя файла для сохранения дерева Хаффмана, например: `tree.txt`.

Программа выполнит кодирование и сохранит результаты в указанные файлы.

#### Декодирование текста:
1. Запустите программу.
2. Выберите режим работы, введя `2`.
3. Укажите:
   - Имя файла с закодированными данными, например: `encoded.txt`.
   - Имя файла с деревом Хаффмана, например: `tree.txt`.
   - Имя файла для сохранения восстановленного текста, например: `decoded.txt`.

Программа выполнит декодирование и сохранит исходный текст в указанный файл.

---

### Детали реализации

#### 1. Кодирование текста
1. **Построение дерева Хаффмана:**
   - Частота символов подсчитывается с использованием `HashMap`.
   - Дерево строится с помощью `PriorityQueue` (кучи), где узлы объединяются, начиная с наименьшей частоты.

2. **Генерация кодов Хаффмана:**
   - Происходит рекурсивный обход дерева (обход в глубину).
   - Для каждого символа создается уникальный двоичный код.

3. **Кодирование строки:**
   - Входной текст преобразуется в строку из 0 и 1 на основе сгенерированных кодов.

4. **Сохранение данных:**
   - Закодированный текст сохраняется в файл (например, `encoded.txt`).
   - Дерево Хаффмана сохраняется в файл (например, `tree.txt`) в формате:
     ```text
     символ:код
     ```

#### 2. Декодирование текста
1. **Загрузка дерева Хаффмана:**
   - Файл с деревом читается и преобразуется в `Map<Character, String>`.

2. **Создание обратного отображения:**
   - Формируется `Map<String, Character>` для преобразования закодированных данных обратно в символы.

3. **Декодирование строки:**
   - Считывается закодированная строка и, используя обратное отображение, преобразуется в исходный текст.

4. **Сохранение результата:**
   - Восстановленный текст сохраняется в файл (например, `decoded.txt`).

---

### Структура данных и файлов

#### 1. Закодированные данные
- Закодированная строка состоит из последовательности `0` и `1`.

#### 2. Дерево Хаффмана
- Хранится в формате:
  ```text
  символ:код
  ```
  Например:
  ```text
  a:0
  b:10
  c:11
  ```

#### 3. Входной/выходной текст
- Текстовые данные читаются и записываются в обычные текстовые файлы (`.txt`).

---

### Обработка ошибок
1. **Проблемы с файлами:**
   - Если файл не найден, программа выводит сообщение:
     ```text
     Произошла ошибка: <описание>
     ```

2. **Неправильный режим работы:**
   - Если введен некорректный номер режима, программа выводит сообщение:
     ```text
     Неверный режим. Попробуйте снова.
     ```

3. **Пустые входные данные:**
   - Если текст для кодирования пуст, программа возвращает пустую строку.

---

### Пример работы

#### Входной текст (`input.txt`):
```text
hello world
```

#### Кодирование:
- Закодированный текст (`encoded.txt`):
  ```text
  1101010011100110111
  ```

- Дерево Хаффмана (`tree.txt`):
  ```text
  h:110
  e:111
  l:01
  o:00
  w:100
  r:101
  d:011
  ```

#### Декодирование:
- Восстановленный текст (`decoded.txt`):
  ```text
  hello world
  ```
